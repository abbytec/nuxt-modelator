// src/module.ts
import { defineNuxtModule, addTemplate, createResolver, addServerHandler, logger } from "@nuxt/kit";
import fg from "fast-glob";
import { join } from "pathe";
import { createJiti } from "jiti";
import { getManifest } from "./registry.js";
import type { ModuleOptions, ModelMeta, Manifest } from "./types.js";

// Auto-import decorators para asegurar que se registren
import "./decorators/transformers/string-transformers.js";
import "./decorators/validators/string-validators.js";

// Templates importados estáticamente (sin extensión)
import runtimeExecutorTpl from "./templates/runtime-executor.tmpl.js";
import manifestTpl from "./templates/manifest.tmpl.js";
import routeHandlerTpl from "./templates/route-handler.tmpl.js";
import piniaStoreTpl from "./templates/pinia-store.tmpl.js";

/** Tipo local y portable para evitar @nuxt/schema en la firma pública */
type PortableNuxtModule<T> = (inlineOptions?: Partial<T>) => any;

const _module = defineNuxtModule<ModuleOptions>({
	meta: {
		name: "nuxt-modelator",
		configKey: "modelator",
	},
	defaults: {
		modelsDir: "domain/models",
		inspector: true,
	},
	async setup(options, nuxt) {
		const { resolve } = createResolver(import.meta.url);

		// Alias para imports generados (debe existir antes de emitir templates)
		nuxt.options.alias = {
			...nuxt.options.alias,
			"#nuxt-modelator": join(nuxt.options.buildDir, "nuxt-modelator"),
		};

		// 1) Cargar modelos (activa decoradores/registry) en build
		const root = nuxt.options.rootDir;
		const modelsGlob = join(root, options.modelsDir!, "**/*.{ts,js,mts,cts}");
		const files = await fg(modelsGlob, { absolute: true, dot: false });
		if (files.length === 0) {
			logger.warn(`[modelator] No se encontraron modelos en ${options.modelsDir}`);
		} else {
			logger.info(`[modelator] Cargando modelos (${files.length})...`);

			// Usar jiti para cargar archivos TypeScript
			const jiti = createJiti(root, {
				interopDefault: true,
			});

			for (const f of files) {
				try {
					await jiti.import(f);
				} catch (error) {
					logger.warn(`[modelator] Error cargando modelo ${f}:`, error);
				}
			}
		}

		// 1b) Template runtime para registrar modelos en el proceso Nitro bajo demanda
		addTemplate({
			filename: "nuxt-modelator/runtime/register-models.mjs",
			getContents: () => `
// Generated by nuxt-modelator
let __loaded = false;
export async function ensureModelsRegistered() {
  if (__loaded) return;
  try {
    const { createJiti } = await import('jiti');
    const jiti = createJiti(process.cwd(), { interopDefault: true });
    const files = ${JSON.stringify(files)};
    for (const f of files) {
      try { await jiti.import(f); } catch (e) { console.warn('[modelator][runtime] Error importando modelo', f, e?.message || e); }
    }
    __loaded = true;
  } catch (e) {
    console.warn('[modelator][runtime] No se pudo inicializar jiti para cargar modelos:', e?.message || e);
  }
}
			`,
		});

		// 2) Manifest
		const manifest: Manifest = getManifest();
		const manifestJson = JSON.stringify(manifest, null, 2);

		// 3) Runtime executor
		addTemplate({
			filename: "nuxt-modelator/runtime/executor.ts",
			getContents: () => runtimeExecutorTpl({ filename: "executor.ts" }),
		});

		// 3b) Middlewares runtime
		addTemplate({
			filename: "nuxt-modelator/runtime/middlewares.ts",
			getContents: () =>
				`export * from '${resolve("./middlewares.server.js")}';\nexport * from '${resolve(
					"./middlewares.client.js"
				)}';\nexport * from '${resolve("./middlewares/registry.js")}';\nexport * from '${resolve("./middlewares/index.js")}';`,
		});

		// 4) Manifest generado
		addTemplate({
			filename: "nuxt-modelator/manifest.ts",
			getContents: () => manifestTpl(manifestJson),
		});

		// 5) Rutas + Stores por modelo
		for (const m of manifest.models) {
			emitRoutesForModel(m, resolve);
			emitPiniaStore(m);
		}

		// 6) Inspector opcional
		if (options.inspector) {
			addServerHandler({
				route: "/__model-inspector",
				handler: resolve("./runtime/inspector.js"),
			});
		}
	},
});

/** Export default tipado con un alias local para evitar la referencia a @nuxt/schema en la firma */
const modulePortable = _module as unknown as PortableNuxtModule<ModuleOptions>;
export default modulePortable;

// ---- helpers ----
function hasServerSpecs(opSpecs: any[]): boolean {
	return (Array.isArray(opSpecs) ? opSpecs : []).some((s) => {
		if (typeof s === "string") return true; // Middlewares tipo string son por defecto "server"
		if (!s) return false;
		const stage = s.stage ?? "server";
		// Considerar válidos: "server" e "isomorphic" (híbridos que se ejecutan en servidor también)
		return stage === "server" || stage === "isomorphic";
	});
}

function emitRoutesForModel(m: ModelMeta, resolve: any) {
	logger.info(`[modelator] Creando endpoints para modelo ${m.resource}:`);

	// GET singular
	if (hasServerSpecs((m.apiMethods as any).get)) {
		addServerHandler({
			route: `${m.basePath}/${m.resource}`,
			handler: resolve("./runtime/universal-handler.js"),
			method: "get",
		});
		logger.info(`[modelator] - GET ${m.basePath}/${m.resource}`);
	}

	// GET colección (si está habilitado y hay server specs)
	if (m.globalConfig.enableList !== false && hasServerSpecs((m.apiMethods as any).getAll)) {
		addServerHandler({
			route: `${m.basePath}/${m.plural}`,
			handler: resolve("./runtime/universal-handler.js"),
			method: "get",
		});
		logger.info(`[modelator] - GET ${m.basePath}/${m.plural}`);
	}

	// POST para crear (si hay specs server en create)
	if (hasServerSpecs((m.apiMethods as any).create)) {
		addServerHandler({
			route: `${m.basePath}/${m.plural}`,
			handler: resolve("./runtime/universal-handler.js"),
			method: "post",
		});
		logger.info(`[modelator] - POST ${m.basePath}/${m.plural}`);
	}

	// PUT para update (si hay specs server)
	if (hasServerSpecs((m.apiMethods as any).update)) {
		addServerHandler({
			route: `${m.basePath}/${m.resource}`,
			handler: resolve("./runtime/universal-handler.js"),
			method: "put",
		});
		logger.info(`[modelator] - PUT ${m.basePath}/${m.resource}`);
	}

	// DELETE para delete (si hay specs server)
	if (hasServerSpecs((m.apiMethods as any).delete)) {
		addServerHandler({
			route: `${m.basePath}/${m.resource}`,
			handler: resolve("./runtime/universal-handler.js"),
			method: "delete",
		});
		logger.info(`[modelator] - DELETE ${m.basePath}/${m.resource}`);
	}

	// Subruta: /by-name (si existen specs server)
	if (hasServerSpecs((m.apiMethods as any).getByName)) {
		addServerHandler({
			route: `${m.basePath}/${m.plural}/by-name`,
			handler: resolve("./runtime/universal-handler.js"),
			method: "get",
		});
		logger.info(`[modelator] - GET ${m.basePath}/${m.plural}/by-name`);
	}
}

function emitPiniaStore(m: ModelMeta) {
	const storeTemplate = addTemplate({
		filename: `nuxt-modelator/stores/use${capitalize(m.resource)}Store.ts`,
		getContents: () =>
			piniaStoreTpl({
				model: m.resource,
				plural: m.plural,
				basePath: m.basePath,
				modelMeta: m,
			}),
	});

	logger.info(`[modelator] Creando store use${capitalize(m.resource)}Store`);
}

function capitalize(s: string) {
	return s.charAt(0).toUpperCase() + s.slice(1);
}
