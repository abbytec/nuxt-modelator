// src/module.ts
import { defineNuxtModule, addTemplate, createResolver, addServerHandler, logger } from "@nuxt/kit";
import fg from "fast-glob";
import { join } from "pathe";
import { createJiti } from "jiti";
import { getManifest } from "./registry.js";
import { clientMiddlewares, serverMiddlewares, hybridMiddlewares, ensureBuiltInMiddlewares } from "./middlewares/auto-registry.js";
import type { ModuleOptions, ModelMeta, Manifest } from "./types.js";

// Auto-import decorators para asegurar que se registren
import "./decorators/transformers/string-transformers.js";
import "./decorators/validators/string-validators.js";

// Templates importados estáticamente (sin extensión)
import runtimeExecutorTpl from "./templates/runtime-executor.tmpl.js";
import manifestTpl from "./templates/manifest.tmpl.js";
import routeHandlerTpl from "./templates/route-handler.tmpl.js";
import piniaStoreTpl from "./templates/pinia-store.tmpl.js";

/** Tipo local y portable para evitar @nuxt/schema en la firma pública */
type PortableNuxtModule<T> = (inlineOptions?: Partial<T>) => any;

const _module = defineNuxtModule<ModuleOptions>({
	meta: {
		name: "nuxt-modelator",
		configKey: "modelator",
	},
	defaults: {
		modelsDir: "domain/models",
		inspector: true,
	},
	async setup(options, nuxt) {
		const { resolve } = createResolver(import.meta.url);

		// Alias para imports generados (debe existir antes de emitir templates)
		nuxt.options.alias = {
			...nuxt.options.alias,
			"#nuxt-modelator": join(nuxt.options.buildDir, "nuxt-modelator"),
		};

		// 1) Cargar modelos (activa decoradores/registry) en build
		const root = nuxt.options.rootDir;
		const modelsGlob = join(root, options.modelsDir!, "**/*.{ts,js,mts,cts}");
		const files = await fg(modelsGlob, { absolute: true, dot: false });
		if (files.length === 0) {
			logger.warn(`[modelator] No se encontraron modelos en ${options.modelsDir}`);
		} else {
			logger.info(`[modelator] Cargando modelos (${files.length})...`);

			// Usar jiti para cargar archivos TypeScript
			const jiti = createJiti(root, { interopDefault: true });

			for (const f of files) {
				try {
					await jiti.import(f);
				} catch (error) {
					logger.warn(`[modelator] Error cargando modelo ${f}:`, error);
				}
			}
		}

		// 1b) Template runtime para registrar modelos en el proceso Nitro bajo demanda
		addTemplate({
			filename: "nuxt-modelator/runtime/register-models.mjs",
			getContents: () => `
// Generated by nuxt-modelator
let __loaded = false;
export async function ensureModelsRegistered() {
  if (__loaded) return;
  try {
    const { createJiti } = await import('jiti');
    const jiti = createJiti(process.cwd(), { interopDefault: true });
    const files = ${JSON.stringify(files)};
    for (const f of files) {
      try { await jiti.import(f); } catch (e) { console.warn('[modelator][runtime] Error importando modelo', f, e?.message || e); }
    }
    __loaded = true;
  } catch (e) {
    console.warn('[modelator][runtime] No se pudo inicializar jiti para cargar modelos:', e?.message || e);
  }
}
			`,
		});

		// 2) Manifest
		const manifest: Manifest = getManifest();
		const manifestJson = JSON.stringify(manifest, null, 2);

		// 3) Runtime executor
		addTemplate({
			filename: "nuxt-modelator/runtime/executor.ts",
			getContents: () => runtimeExecutorTpl({ filename: "executor.ts" }),
		});

		// 3b) Middlewares runtime
		addTemplate({
			filename: "nuxt-modelator/runtime/middlewares.ts",
			getContents: () =>
				`export * from '${resolve("./middlewares.server.js")}';\nexport * from '${resolve(
					"./middlewares.client.js"
				)}';\nexport * from '${resolve("./middlewares/registry.js")}';\nexport * from '${resolve("./middlewares/index.js")}';`,
		});

                // 4) Manifest generado
                addTemplate({
                        filename: "nuxt-modelator/manifest.ts",
                        getContents: () => manifestTpl(manifestJson),
                });

                // Asegurar que los middlewares built-in estén registrados para detectar stages
                await ensureBuiltInMiddlewares();

                // 5) Rutas + Stores por modelo
                for (const m of manifest.models) {
                        emitRoutesForModel(m, resolve);
                        emitPiniaStore(m);
                }

		// 6) Inspector opcional
		if (options.inspector) {
			addServerHandler({
				route: "/__model-inspector",
				handler: resolve("./runtime/inspector.js"),
			});
		}
	},
});

/** Export default tipado con un alias local para evitar la referencia a @nuxt/schema en la firma */
const modulePortable = _module as unknown as PortableNuxtModule<ModuleOptions>;
export default modulePortable;

// ---- helpers ----
const requestMiddlewareNames = new Set([
        "postRequest",
        "postAllRequest",
        "getRequest",
        "getAllRequest",
        "putRequest",
        "putAllRequest",
        "deleteRequest",
        "deleteAllRequest",
]);

function getMiddlewareStage(name: string, args?: any): "server" | "client" | "hybrid" {
        if (serverMiddlewares[name]) return "server";
        if (clientMiddlewares[name]) return "client";
        if (hybridMiddlewares[name]) {
                if (requestMiddlewareNames.has(name) && args && typeof args === "object" && (args as any).url) {
                        return "client";
                }
                return "hybrid";
        }
        return "server";
}

function hasServerSpecs(opSpecs: any[]): boolean {
        const specs = Array.isArray(opSpecs) ? opSpecs : [];

        const hasExternalRequest = specs.some(
                (s) =>
                        typeof s === "object" &&
                        requestMiddlewareNames.has(s.name) &&
                        s.args &&
                        typeof s.args === "object" &&
                        (s.args as any).url
        );
        if (hasExternalRequest) return false;

        return specs.some((s: any) => {
                if (!s) return false;
                const name = typeof s === "string" ? s : s.name;
                const args = typeof s === "object" ? s.args : undefined;
                const stage = getMiddlewareStage(name, args);
                return stage === "server" || stage === "hybrid";
        });
}

function addRoute(route: string, method: "get" | "post" | "put" | "delete", resolve: any) {
	addServerHandler({ route, handler: resolve("./runtime/universal-handler.js"), method });
	logger.info(`[modelator] - ${method.toUpperCase()} ${route}`);
}

function emitRoutesForModel(m: ModelMeta, resolve: any) {
	logger.info(`[modelator] Creando endpoints para modelo ${m.resource}:`);

	// === GET ===
	// Singular
	if (hasServerSpecs((m.apiMethods as any).get)) {
		addRoute(`${m.basePath}/${m.resource}`, "get", resolve);
	}
	// Colección
	if (m.globalConfig.enableList !== false && hasServerSpecs((m.apiMethods as any).getAll)) {
		addRoute(`${m.basePath}/${m.plural}`, "get", resolve);
	}

        // === POST (CREATE) ===
        // Singular (alias para create one)
        if (hasServerSpecs((m.apiMethods as any).create)) {
                addRoute(`${m.basePath}/${m.resource}`, "post", resolve);
        }
        // Colección (create many / create on collection)
        if (m.globalConfig.enableList !== false && hasServerSpecs((m.apiMethods as any).createAll)) {
                addRoute(`${m.basePath}/${m.plural}`, "post", resolve);
        }

        // === SAVE OR UPDATE (UPSERT) ===
        if (m.globalConfig.enableList !== false && hasServerSpecs((m.apiMethods as any).saveOrUpdate)) {
                addRoute(`${m.basePath}/${m.plural}`, "post", resolve);
        }

        // === PUT (UPDATE) ===
        // Singular (update one)
        if (hasServerSpecs((m.apiMethods as any).update)) {
                addRoute(`${m.basePath}/${m.resource}`, "put", resolve);
        }
        // Colección (bulk update)
        if (m.globalConfig.enableList !== false && hasServerSpecs((m.apiMethods as any).updateAll)) {
                addRoute(`${m.basePath}/${m.plural}`, "put", resolve);
        }

        // === DELETE ===
        // Singular (delete one)
        if (hasServerSpecs((m.apiMethods as any).delete)) {
                addRoute(`${m.basePath}/${m.resource}`, "delete", resolve);
        }
        // Colección (bulk delete)
        if (m.globalConfig.enableList !== false && hasServerSpecs((m.apiMethods as any).deleteAll)) {
                addRoute(`${m.basePath}/${m.plural}`, "delete", resolve);
        }

	// === Subrutas por nombre ===
	// Singular: /by-name (alias)
	if (hasServerSpecs((m.apiMethods as any).getByName)) {
		addRoute(`${m.basePath}/${m.resource}/by-name`, "get", resolve);
	}
	// Plural: /by-name (colección)
	if (m.globalConfig.enableList !== false && hasServerSpecs((m.apiMethods as any).getByName)) {
		addRoute(`${m.basePath}/${m.plural}/by-name`, "get", resolve);
	}
}

function emitPiniaStore(m: ModelMeta) {
	addTemplate({
		filename: `nuxt-modelator/stores/use${capitalize(m.resource)}Store.ts`,
		getContents: () =>
			piniaStoreTpl({
				model: m.resource,
				plural: m.plural,
				basePath: m.basePath,
				modelMeta: m,
			}),
	});
	logger.info(`[modelator] Creando store use${capitalize(m.resource)}Store`);
}

function capitalize(s: string) {
	return s.charAt(0).toUpperCase() + s.slice(1);
}
