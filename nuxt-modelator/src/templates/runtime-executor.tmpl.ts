export default (opts: { filename: string }) => `
// Generated by nuxt-modelator
import { eventHandler, getQuery, H3Event, setResponseStatus, readBody } from 'h3'
import { executeHybridMiddlewares } from '../middlewares/hybrid-executor.js'
import { defaultReturn } from '../middlewares.server.js'

type MWSpec = string | { name: string; args?: any }
type ValidationError = { field: string; value: any; rule: string; message: string; args?: any }

// Sistema de validación simplificado para el servidor
function validateField(value: any, field: string, transforms: any[]): ValidationError[] {
  const errors: ValidationError[] = [];
  
  for (const transform of transforms || []) {
    if (transform.kind === 'validate') {
      const validator = transform.validator;
      const config = transform.config || {};
      
      // Validaciones básicas implementadas directamente
      if (validator.name === 'required') {
        if (value === null || value === undefined || (typeof value === 'string' && value.trim().length === 0)) {
          errors.push({
            field,
            value,
            rule: 'required',
            message: config.message || 'Field is required',
            args: config.args
          });
        }
      }
      
      if (validator.name === 'maxLength' && typeof value === 'string') {
        const maxLength = config.args?.maxLength || 255;
        if (value.length > maxLength) {
          errors.push({
            field,
            value,
            rule: 'maxLength',
            message: config.message || \`Value exceeds maximum length of \${maxLength}\`,
            args: config.args
          });
        }
      }
      
      if (validator.name === 'email' && typeof value === 'string') {
        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
        if (!emailRegex.test(value)) {
          errors.push({
            field,
            value,
            rule: 'email',
            message: config.message || 'Invalid email format',
            args: config.args
          });
        }
      }
    }
  }
  
  return errors;
}

// Sistema de transformación simplificado para el servidor
function transformField(value: any, field: string, transforms: any[]): any {
  let result = value;
  
  for (const transform of transforms || []) {
    if (transform.kind === 'transform') {
      const transformer = transform.transformer;
      
      // Transformaciones básicas implementadas directamente
      if (transformer.name === 'toLowerCase' && typeof result === 'string') {
        result = result.toLowerCase();
      }
      
      if (transformer.name === 'toUpperCase' && typeof result === 'string') {
        result = result.toUpperCase();
      }
      
      if (transformer.name === 'trim' && typeof result === 'string') {
        result = result.trim();
      }
      
      if (transformer.name === 'capitalize' && typeof result === 'string' && result.length > 0) {
        result = result.charAt(0).toUpperCase() + result.slice(1).toLowerCase();
      }
    }
  }
  
  return result;
}

async function processModelValidation(data: any, modelMeta: any): Promise<{ transformedData: any; isValid: boolean; errors: ValidationError[] }> {
  const transformedData = { ...data };
  const allErrors: ValidationError[] = [];
  
  for (const prop of modelMeta.props || []) {
    if (data.hasOwnProperty(prop.name)) {
      let value = data[prop.name];
      
      // Aplicar transformaciones
      value = transformField(value, prop.name, prop.transforms);
      transformedData[prop.name] = value;
      
      // Aplicar validaciones
      const validationErrors = validateField(value, prop.name, prop.transforms);
      allErrors.push(...validationErrors);
    }
  }
  
  return {
    transformedData,
    isValid: allErrors.length === 0,
    errors: allErrors
  };
}

async function runPipeline(event: H3Event, model: string, op: string, specs: MWSpec[], customReturnName?: string, modelMeta?: any) {
  const state: Record<string, any> = {}
  const args = getQuery(event)
  let returned = false
  let payload: any

  const done = (p: any) => { returned = true; payload = p }

  // Validaciones de entrada para operaciones que reciben datos
  if (['create', 'update'].includes(op)) {
    try {
      const body = await readBody(event);
      if (body && modelMeta) {
        const validation = await processModelValidation(body, modelMeta);

        if (!validation.isValid) {
          return {
            status: 400,
            code: 'VALIDATION_ERROR',
            message: 'Validation failed',
            validationErrors: validation.errors
          };
        }

        // Pasar los datos transformados al estado
        state.validatedData = validation.transformedData;
      }
    } catch (e) {
      console.warn('Body validation error:', e);
    }
  }

  await executeHybridMiddlewares(specs as any, { event, op, model, args, state, done, stage: 'server' })

  if (!returned) {
    // usar customReturn si se configuró, si no default
    const resolver = defaultReturn
    payload = await resolver({ event, op, model, state })
  }

  // normalizar respuesta demo
  const status = payload?.status && Number.isInteger(payload.status) ? payload.status : 200
  if (status !== 200) setResponseStatus(event, status)
  return payload
}

export const makeHandler = (model: string, op: string, specs: MWSpec[], customReturnName?: string, modelMeta?: any) => {
  return eventHandler(async (event) => {
    return await runPipeline(event, model, op, specs, customReturnName, modelMeta)
  })
}
`;
