function capitalize(s: string) {
	return s.charAt(0).toUpperCase() + s.slice(1);
}

export default (args: { model: string; plural: string; basePath: string; modelMeta: any }) => `
// Generated by nuxt-modelator
import { defineStore } from 'pinia'
import { clientMiddlewares, hybridMiddlewares, executeMiddlewaresWithComposition } from '#nuxt-modelator/runtime/middlewares'
import { decoratorRegistry } from 'nuxt-modelator/dist/decorators'

type ErrorShape = { code?: string; message?: string; details?: any }
type ValidationError = { field: string; value: any; rule: string; message: string; args?: any }

const isClient = typeof window !== 'undefined'

const clientOps: Record<string, any[]> = Object.fromEntries(
  Object.entries((${JSON.stringify(args.modelMeta?.apiMethods || {})} as any)).map(([op, specs]: any) => [
    op,
    (Array.isArray(specs) ? specs : []).filter((s: any) => {
      if (typeof s === 'string') return false // String middlewares son server-only
      const stage = s.stage ?? 'server'
      // Incluir client e isomorphic (híbridos), excluir solo server
      return stage === 'client' || stage === 'isomorphic'
    })
  ])
)

function unwrapInput<T = any>(input: any): T {
  // Desreferenciar valores tipo ref/reactivo comunes de Vue sin importar Vue aquí
  if (input && typeof input === 'object' && 'value' in input && input.value !== undefined) {
    return (input as any).value as T
  }
  return input as T
}

function normalizeOpArgs(op: string, input: any): any {
  const value = unwrapInput<any>(input)
  if (value == null) return undefined
  if (typeof value === 'object' && !Array.isArray(value)) return value
  if (op === 'search') return { query: value }
  if (op.startsWith('getBy') && op.length > 5) {
    const key = op.slice(5)
    const argKey = key.charAt(0).toLowerCase() + key.slice(1)
    return { [argKey]: value }
  }
  return { value }
}

async function validateField(value: any, field: string, transforms: any[]): Promise<ValidationError[]> {
  const validations = (transforms || [])
    .filter((t: any) => t.kind === 'validate')
    .map((t: any) => {
      const cfg = t?.config || {}
      const vName = t?.validator?.name as string | undefined
      let validator = vName ? decoratorRegistry.getValidator(vName) : undefined
      if (!validator && vName) {
        const factory = decoratorRegistry.getValidatorFactory(vName)
        if (typeof factory === 'function') {
          validator = factory(cfg.args)
        }
      }
      return validator ? { validator, config: cfg } : null
    })
    .filter(Boolean) as Array<{ validator: any; config: any }>
  if (validations.length === 0) return []
  const { errors } = await decoratorRegistry.applyValidations(value, field, '${args.model}', 'client', validations as any)
  return errors as any
}

async function transformField(value: any, field: string, transforms: any[]): Promise<any> {
  const txs = (transforms || [])
    .filter((t: any) => t.kind === 'transform')
    .map((t: any) => {
      const tName = t?.transformer?.name
      const transformer = tName ? decoratorRegistry.getTransformer(tName) : undefined
      return transformer ? { transformer, config: t.config || {} } : null
    })
    .filter(Boolean) as Array<{ transformer: any; config: any }>
  if (txs.length === 0) return value
  return await decoratorRegistry.applyTransforms(value, field, '${args.model}', 'client', txs as any)
}

async function runClientPipeline(ctx: { op: string; model: string; args: any; state: any }): Promise<any> {
  const specs = clientOps[ctx.op] || []
  if (!specs.length) return { __noClientPipeline: true }
  let returned = false; let payload: any
  const done = (p: any) => { returned = true; payload = p }
  const argsRef = ctx.args

  // Ejecutar usando el ejecutor de composición para garantizar next()
  await executeMiddlewaresWithComposition(specs, {
    op: ctx.op,
    model: ctx.model,
    args: ctx.args,
    state: ctx.state,
    done,
    stage: 'client'
  } as any)

  if (returned) return payload
  if (argsRef && typeof argsRef === 'object' && 'data' in argsRef) return { __clientHandled: true, payload: (argsRef as any).data }
  if (ctx.state && (ctx.state as any).httpNormalizedData) return (ctx.state as any).httpNormalizedData
  return { __continue: true }
}

function safeCheckFlag(obj: any, flag: string): boolean {
  return obj && typeof obj === 'object' && obj[flag] === true
}

export const use${capitalize(args.model)}Store = defineStore('modelator:${args.model}', {
  state: () => ({
    entity: null as any,
    all: [] as any[],
    loading: {} as Record<string, boolean>,
    errors: {} as Record<string, ErrorShape | null>,
    validationErrors: {} as Record<string, ValidationError[]>,
    __basePath: ${JSON.stringify(args.basePath)},
    __model: ${JSON.stringify(args.model)},
    __plural: ${JSON.stringify(args.plural)},
  }),
  actions: {
    async processFields(data: any): Promise<{ transformedData: any; isValid: boolean; errors: ValidationError[] }> {
      const source = unwrapInput<any>(data)
      const transformedData: Record<string, any> = { ...(source || {}) }
      const allErrors: ValidationError[] = []
      const modelMeta = ${JSON.stringify(args.modelMeta || {})}
      for (const prop of modelMeta.props || []) {
        if (source && Object.prototype.hasOwnProperty.call(source, prop.name)) {
          let value = (source as any)[prop.name]
          value = await transformField(value, prop.name, prop.transforms)
          transformedData[prop.name] = value
          const validationErrors = await validateField(value, prop.name, prop.transforms)
          allErrors.push(...validationErrors)
        }
      }
      return { transformedData, isValid: allErrors.length === 0, errors: allErrors }
    },
    async get(params?: any) {
      if (!isClient) { console.warn('Store action called on server, skipping'); return null; }
      const op = 'get'; this.loading[op] = true; this.errors[op] = null; this.validationErrors[op] = [];
      try {
        const clientResult: any = await runClientPipeline({ op, model: '${args.model}', args: params, state: this })
        if (safeCheckFlag(clientResult, '__noClientPipeline')) return this.entity
        if (safeCheckFlag(clientResult, '__clientHandled')) { this.entity = clientResult.payload; return this.entity }
        if (!safeCheckFlag(clientResult, '__continue')) { this.entity = clientResult; return clientResult }
        return this.entity
      } catch (e: any) { this.errors[op] = normalizeError(e); throw e } finally { this.loading[op] = false }
    },
    async getAll(params?: any) {
      if (!isClient) { console.warn('Store action called on server, skipping'); return []; }
      const op = 'getAll'; this.loading[op] = true; this.errors[op] = null; this.validationErrors[op] = [];
      try {
        const clientResult: any = await runClientPipeline({ op, model: '${args.model}', args: params, state: this })
        if (safeCheckFlag(clientResult, '__noClientPipeline')) return this.all
        if (safeCheckFlag(clientResult, '__clientHandled')) { const data = clientResult.payload; this.all = Array.isArray(data?.items) ? data.items : (Array.isArray(data) ? data : []); return data }
        if (!safeCheckFlag(clientResult, '__continue')) { const data = clientResult; this.all = Array.isArray(data?.items) ? data.items : (Array.isArray(data) ? data : []); return data }
        return this.all
      } catch (e: any) { this.errors[op] = normalizeError(e); throw e } finally { this.loading[op] = false }
    },
    async getByName(name: string) {
      if (!isClient) { console.warn('Store action called on server, skipping'); return null; }
      const op = 'getByName'; this.loading[op] = true; this.errors[op] = null; this.validationErrors[op] = [];
      try {
        const clientResult: any = await runClientPipeline({ op, model: '${args.model}', args: { name }, state: this })
        if (safeCheckFlag(clientResult, '__noClientPipeline')) return null
        if (safeCheckFlag(clientResult, '__clientHandled')) { this.entity = clientResult.payload; return this.entity }
        if (!safeCheckFlag(clientResult, '__continue')) { this.entity = clientResult; return clientResult }
        return null
      } catch (e: any) { this.errors[op] = normalizeError(e); throw e } finally { this.loading[op] = false }
    },
    async create(data: any) {
      if (!isClient) { console.warn('Store action called on server, skipping'); return null; }
      const op = 'create'; this.loading[op] = true; this.errors[op] = null; this.validationErrors[op] = [];
      const unwrapped = unwrapInput<any>(data)
      const { transformedData, isValid, errors } = await this.processFields(unwrapped);
      if (!isValid) { this.validationErrors[op] = errors; this.loading[op] = false; return null; }
      
      // Setear validatedData para que postRequest lo use
      (this as any).validatedData = transformedData;
      
      try {
        const clientResult: any = await runClientPipeline({ op, model: '${args.model}', args: { data: transformedData }, state: this })
        if (safeCheckFlag(clientResult, '__noClientPipeline')) { throw new Error('No request middleware configured for create') }
        if (safeCheckFlag(clientResult, '__clientHandled')) {
          const payload = clientResult.payload
          if (payload && !Array.isArray(payload)) { if (!Array.isArray(this.all)) this.all = []; this.all.unshift(payload) }
          return payload
        }
        if (!safeCheckFlag(clientResult, '__continue')) {
          const payload = clientResult
          if (payload && !Array.isArray(payload)) { if (!Array.isArray(this.all)) this.all = []; this.all.unshift(payload) }
          return payload
        }
        throw new Error('No middleware produced a result')
      } catch (e: any) {
        const err = normalizeError(e)
        this.errors[op] = err
        const vErrs = (err as any)?.validationErrors
        if (Array.isArray(vErrs)) { this.validationErrors[op] = vErrs; return null }
        throw e
      } finally { 
        delete (this as any).validatedData; this.loading[op] = false 
      }
    },
    ${(() => {
		const builtIns = new Set(["get", "getAll", "getByName", "create"]);
		const ops: string[] = Object.keys(args.modelMeta?.apiMethods || {}).filter((k) => !builtIns.has(k));
		return ops
			.map(
				(op) => `
    async ${op}(params?: any) {
      if (!isClient) { console.warn('Store action called on server, skipping'); return null; }
      const op = '${op}'; this.loading[op] = true; this.errors[op] = null; this.validationErrors[op] = [];
      try {
        const mapped = normalizeOpArgs(op, params)
        const clientResult: any = await runClientPipeline({ op, model: '${args.model}', args: mapped, state: this })
        if (safeCheckFlag(clientResult, '__noClientPipeline')) return null
        if (safeCheckFlag(clientResult, '__clientHandled')) { const data = clientResult.payload; if (Array.isArray(data)) this.all = data; else this.entity = data; return data }
        if (!safeCheckFlag(clientResult, '__continue')) { const data = clientResult; if (Array.isArray(data?.items)) { this.all = data.items } else if (Array.isArray(data)) { this.all = data } else { this.entity = data }; return data }
        return null
      } catch (e: any) { this.errors[op] = normalizeError(e); throw e } finally { this.loading[op] = false }
    }`
			)
			.join(",\n");
	})()}
  }
})

function normalizeError(e: any): ErrorShape { if (e?.data && typeof e.data === 'object') return e.data; if (e?.message) return { message: e.message }; return { message: 'unknown_error' } }
`;
